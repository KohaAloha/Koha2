#!/usr/bin/perl

# $Id$

# Database Updater
# This script checks for required updates to the database.

# Part of the Koha Library Software www.koha.org
# Licensed under the GPL.

# Bugs/ToDo:
# - Would also be a good idea to offer to do a backup at this time...

# NOTE:  If you do something more than once in here, make it table driven.
use strict;

# CPAN modules
use DBI;
use Getopt::Long;
# Koha modules
use C4::Context;

use MARC::Record;
use MARC::File::XML ( BinaryEncoding => 'utf8' );
 
# FIXME - The user might be installing a new database, so can't rely
# on /etc/koha.conf anyway.

my $debug = 0;

my (
    $sth, $sti,
    $query,
    %existingtables,    # tables already in database
    %types,
    $table,
    $column,
    $type, $null, $key, $default, $extra,
    $prefitem,          # preference item in systempreferences table
);

my $silent;
GetOptions(
    's' =>\$silent
    );
my $dbh = C4::Context->dbh;
print "connected to your DB. Checking & modifying it\n" unless $silent;
$|=1; # flushes output

#-------------------
# Defines

# Tables to add if they don't exist
my %requiretables = (
    categorytable       => "(categorycode char(5) NOT NULL default '',
                             description text default '',
                             itemtypecodes text default '',
                             PRIMARY KEY (categorycode)
                            )",
    subcategorytable       => "(subcategorycode char(5) NOT NULL default '',
                             description text default '',
                             itemtypecodes text default '',
                             PRIMARY KEY (subcategorycode)
                            )",
    mediatypetable       => "(mediatypecode char(5) NOT NULL default '',
                             description text default '',
                             itemtypecodes text default '',
                             PRIMARY KEY (mediatypecode)
                            )",
    action_logs     => "(
                    `timestamp` TIMESTAMP NOT NULL ,
                    `user` INT( 11 ) NOT NULL ,
                    `module` TEXT default '',
                    `action` TEXT default '' ,
                    `object` INT(11) default '' ,
                    `info` TEXT default '' ,
                    PRIMARY KEY ( `timestamp` , `user` )
                )",
    letter        => "(
                    module varchar(20) NOT NULL default '',
                    code varchar(20) NOT NULL default '',
                    name varchar(100) NOT NULL default '',
                    title varchar(200) NOT NULL default '',
                    content text,
                    PRIMARY KEY  (module,code)
                )",
    alert        =>"(
                    alertid int(11) NOT NULL auto_increment,
                    borrowernumber int(11) NOT NULL default '0',
                    type varchar(10) NOT NULL default '',
                    externalid varchar(20) NOT NULL default '',
                    PRIMARY KEY  (alertid),
                    KEY borrowernumber (borrowernumber),
                    KEY type (type,externalid)
                )",
    opac_news => "(
                `idnew` int(10) unsigned NOT NULL auto_increment,
                `title` varchar(250) NOT NULL default '',
                `new` text NOT NULL,
                `lang` varchar(4) NOT NULL default '',
                `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
                PRIMARY KEY  (`idnew`)
                )",
    repeatable_holidays => "(
                `id` int(11) NOT NULL auto_increment,
                `branchcode` varchar(4) NOT NULL default '',
                `weekday` smallint(6) default NULL,
                `day` smallint(6) default NULL,
                `month` smallint(6) default NULL,
                `title` varchar(50) NOT NULL default '',
                `description` text NOT NULL,
                PRIMARY KEY  (`id`)
                )",
    special_holidays => "(
                `id` int(11) NOT NULL auto_increment,
                `branchcode` varchar(4) NOT NULL default '',
                `day` smallint(6) NOT NULL default '0',
                `month` smallint(6) NOT NULL default '0',
                `year` smallint(6) NOT NULL default '0',
                `isexception` smallint(1) NOT NULL default '1',
                `title` varchar(50) NOT NULL default '',
                `description` text NOT NULL,
                PRIMARY KEY  (`id`)
                )",
    overduerules    =>"(`branchcode` varchar(255) NOT NULL default '',
                    `categorycode` char(2) NOT NULL default '',
                    `delay1` int(4) default '0',
                    `letter1` varchar(20) default NULL,
                    `debarred1` char(1) default '0',
                    `delay2` int(4) default '0',
                    `debarred2` char(1) default '0',
                    `letter2` varchar(20) default NULL,
                    `delay3` int(4) default '0',
                    `letter3` varchar(20) default NULL,
                    `debarred3` int(1) default '0',
                    PRIMARY KEY  (`branchcode`,`categorycode`)
                    )",
    cities            => "(`cityid` int auto_increment,
                        `city_name` char(100) NOT NULL,
                        `city_zipcode` char(20),
                        PRIMARY KEY (`cityid`)
                    )",
    roadtype            => "(`roadtypeid` int auto_increment,
                        `road_type` char(100) NOT NULL,
                        PRIMARY KEY (`roadtypeid`)
                    )",

    labels                     => "(
                labelid int(11) NOT NULL auto_increment,
                               itemnumber varchar(100) NOT NULL default '',
                               timestamp timestamp(14) NOT NULL,
                               PRIMARY KEY  (labelid)
                               )",

    labels_conf                => "(
                id int(4) NOT NULL auto_increment,
                               barcodetype char(100) default '',
                               title tinyint(1) default '0',
                               isbn tinyint(1) default '0',
                               itemtype tinyint(1) default '0',
                               barcode tinyint(1) default '0',
                               dewey tinyint(1) default '0',
                               class tinyint(1) default '0',
                               author tinyint(1) default '0',
                               papertype char(100) default '',
                               startrow int(2) default NULL,
                               PRIMARY KEY  (id)
                               )",
       reviews                  => "(
                            reviewid integer NOT NULL auto_increment,
                            borrowernumber integer,
                            biblionumber integer,
                            review text,
                            approved tinyint,
                            datereviewed datetime,
                            PRIMARY KEY (reviewid)
                            )",
    borrowers_to_borrowers  => "(
                            borrower1 integer,
                            borrower2 integer
                            )",
    subscriptionroutinglist=>"(
                             routingid integer NOT NULL auto_increment,
                             borrowernumber integer,
                             ranking integer,
                             subscriptionid integer,
                            PRIMARY KEY (routingid)
                             )",

    notifys    => "(
              notify_id int(11) NOT NULL default '0',
                `borrowernumber` int(11) NOT NULL default '0',
              `itemnumber` int(11) NOT NULL default '0',
              `notify_date` date NOT NULL default '0000-00-00',
                      `notify_send_date` date default NULL,
                      `notify_level` int(1) NOT NULL default '0',
                      `method` varchar(20) NOT NULL default ''
              )",

   charges    => "(
              `charge_id` varchar(5) NOT NULL default '',
                `description` text NOT NULL,
                `amount` decimal(28,6) NOT NULL default '0.000000',
                          `min` int(4) NOT NULL default '0',
                `max` int(4) NOT NULL default '0',
                          `level` int(1) NOT NULL default '0',
                          PRIMARY KEY  (`charge_id`)
              )",
    tags => "(
        `entry` varchar(255) NOT NULL default '',
        `weight` bigint(20) NOT NULL default '0',
         PRIMARY KEY  (`entry`)
    )
    ",
   zebraqueue    => "(
                `id` int NOT NULL auto_increment,
                `biblio_auth_number` int NOT NULL,
                `operation` char(20) NOT NULL,
                `server` char(20) NOT NULL ,
                PRIMARY KEY  (`id`)
              ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci AUTO_INCREMENT=1",

);

my %requirefields = (
    subscription => { 'letter' => 'char(20) NULL', 'distributedto' => 'text NULL', 'firstacquidate'=>'date NOT NULL','irregularity'=>'TEXT NULL default \'\'','numberpattern'=>'TINYINT(3) NULL default 0', 'callnumber'=>'text NULL', 'hemisphere' =>'TINYINT(3) NULL default 0', 'issuesatonce'=>'TINYINT(3) NOT NULL default 1',  'branchcode' =>'varchar(12) NOT NULL default \'\'', 'manualhistory'=>'TINYINT(1) NOT NULL default 0','internalnotes'=>'LONGTEXT NULL default \'\''},
    itemtypes => { 'imageurl' => 'char(200) NULL'},
    aqbookfund => { 'branchcode' => 'varchar(4) NULL'},
    aqbudget => { 'branchcode' => 'varchar(4) NULL'},
    auth_header => { 'marc' => 'BLOB NOT NULL', 'linkid' => 'BIGINT(20) NULL'},
    auth_subfield_structure =>{ 'hidden' => 'TINYINT(3) NOT NULL default 0', 'kohafield' => 'VARCHAR(45) NOT NULL', 'linkid' =>  'TINYINT(1) NOT NULL default 0', 'isurl' => 'TINYINT(1)', 'frameworkcode'=>'VARCHAR(8) NOT  NULL'},
    marc_breeding => { 'isbn' => 'varchar(13) NOT NULL'},
    serial =>{ 'publisheddate' => 'date', 'claimdate' => 'date', 'itemnumber'=>'text NULL','routingnotes'=>'text NULL',},
    statistics => { 'associatedborrower' => 'integer'},
    z3950servers =>{  "name" =>"text",  "description" => "text NOT NULL",
                    "position" =>"enum('primary','secondary','') NOT NULL default 'primary'",  "icon" =>"text",
                    "type" =>"enum('zed','opensearch') NOT NULL default 'zed'",
                    },
    issues =>{ 'issuedate'=>"date NOT NULL default '0000-00-00'", },

#    tablename        => { 'field' => 'fieldtype' },
);

# Enter here the table to delete.
my @TableToDelete = qw(
    additionalauthors
    bibliosubject
    bibliosubtitle
);

my %uselessfields = (
# tablename => "field1,field2",
    borrowers => "suburb,altstreetaddress,altsuburb,altcity,studentnumber,school,area,preferredcont,altcp",
    deletedborrowers=> "suburb,altstreetaddress,altsuburb,altcity,studentnumber,school,area,preferredcont,altcp",
    );
# the other hash contains other actions that can't be done elsewhere. they are done
# either BEFORE of AFTER everything else, depending on "when" entry (default => AFTER)

# The tabledata hash contains data that should be in the tables.
# The uniquefieldrequired hash entry is used to determine which (if any) fields
# must not exist in the table for this row to be inserted.  If the
# uniquefieldrequired entry is already in the table, the existing data is not
# modified, unless the forceupdate hash entry is also set.  Fields in the
# anonymous "forceupdate" hash will be forced to be updated to the default
# values given in the %tabledata hash.

my %tabledata = (
# tablename => [
#    {    uniquefielrequired => 'fieldname', # the primary key in the table
#        fieldname => fieldvalue,
#        fieldname2 => fieldvalue2,
#    },
# ],
    systempreferences => [
        {
            uniquefieldrequired => 'variable',
            variable            => 'useDaysMode',
            value               => 'Calendar',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation            => 'How to calculate return dates : Calendar means holidays will be controled, Days means the return date don\'t depend on holidays',
            type        => 'Choice',
            options        => 'Calendar|Days'
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'BorrowersTitles',
            value               => 'Mr|Mrs|Miss|Ms',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'List all Titles for borrowers',
            type                => 'free',
        },
	{
            uniquefieldrequired => 'variable',
            variable            => 'BorrowerMandatoryField',
            value               => 'cardnumber|surname|address',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'List all mandatory fields for borrowers',
            type                => 'free',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'borrowerRelationship',
            value               => 'father|mother,grand-mother',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'The relationships between a guarantor & a guarantee (separated by | or ,)',
            type                => 'free',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'ReservesMaxPickUpDelay',
            value               => '10',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Maximum delay to pick up a reserved document',
            type                => 'free',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'TransfersMaxDaysWarning',
            value               => '3',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Max delay before considering the transfer has potentialy a problem',
            type                => 'free',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'memberofinstitution',
            value               => '0',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Are your patrons members of institutions',
            type                => 'YesNo',
        },
    {
            uniquefieldrequired => 'variable',
            variable            => 'ReadingHistory',
            value               => '0',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Allow reading record info retrievable from issues and oldissues tables',
            type                => 'YesNo',
        },
    {
            uniquefieldrequired => 'variable',
            variable            => 'IssuingInProcess',
            value               => '0',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Allow no debt alert if the patron is issuing item that accumulate debt',
            type                => 'YesNo',
        },
    {
            uniquefieldrequired => 'variable',
            variable            => 'AutomaticItemReturn',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'This Variable allow or not to return automaticly to his homebranch',
            type                => 'YesNo',
        },
    {
            uniquefieldrequired => 'variable',
            variable            => 'reviewson',
            value               => '0',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Allows patrons to submit reviews from the opac',
            type                => 'YesNo',
        },
    {
            uniquefieldrequired => 'variable',
            variable            => 'intranet_includes',
            value               => 'includes',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'The includes directory you want for specific look of Koha (includes or includes_npl for example)',
            type                => 'Free',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'AutoLocation',
            value               => '0',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'switch to activate or not Autolocation, if Yes, the Librarian can\'t change his location, it\'s defined by branchip',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'serialsadditems',
            value               => '0',
            forceupdate         => {
                'explanation' => 1,
                'type' => 1
            },
            explanation => 'If set, a new item will be automatically added when receiving an issue',
            type => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'expandedSearchOption',
            value               => '0',
            forceupdate         => {
                'explanation' => 1,
                'type' => 1
            },
            explanation => 'search among marc field',
            type => 'YesNo',
        },
       {
            uniquefieldrequired => 'variable',
            variable            => 'RequestOnOpac',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'option to allow reserves on opac',
            type                => 'YesNo',
        },
       {
            uniquefieldrequired => 'variable',
            variable            => 'OpacCloud',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Enable / Disable cloud link on OPAC',
            type                => 'YesNo',
        },
       {
            uniquefieldrequired => 'variable',
            variable            => 'OpacBrowser',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Enable/Disable browser link on OPAC (needs to set misc/cronjob/build_browser.pl)',
            type                => 'YesNo',
        },
       {
            uniquefieldrequired => 'variable',
            variable            => 'OpacTopissue',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Enable / Disable the top issue link on OPAC',
            type                => 'YesNo',
        },
       {
            uniquefieldrequired => 'variable',
            variable            => 'OpacAuthorities',
            value               => '1',
            forceupdate         => { 'explanation' => 1,
                                     'type' => 1},
            explanation         => 'Enable / Disable the search authority link on OPAC',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'CataloguingLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log cataloguing action.',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'BorrowersLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log borrowers edition/creation/deletion...',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'SubscriptionLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log Subscription action',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'IssueLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log issue.',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'ReturnLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log the circulation return',
            type                => 'YesNo',
        },
        {   
            uniquefieldrequired => 'variable',
            variable            => 'LetterLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log all the letter sent',
            type                => 'YesNo',
        },
        {
            uniquefieldrequired => 'variable',
            variable            => 'FinesLog',
            value               => '0',
            forceupdate         => {'explanation' => 1, 'type' => 1},
            explanation         => 'Active this if you want to log fines',
            type                => 'YesNo',
        },
    ],
    userflags => [
        {
            uniquefieldrequired => 'bit',
            bit                 => '14',
            flag                => 'editauthorities',
            flagdesc            => 'allow to edit authorities',
            defaulton           => '0',
        },
        {
            uniquefieldrequired => 'bit',
            bit                 => '15',
            flag                 => 'serials',
            flagdesc            => 'allow to manage serials subscriptions',
            defaulton           => '0',
        },
        {
            uniquefieldrequired => 'bit',
            bit                 => '16',
            flag                 => 'reports',
            flagdesc            => 'allow to access to the reports module',
            defaulton           => '0',
        },
    ],
    authorised_values => [
        {
            uniquefieldrequired => 'id',
            category            => 'SUGGEST',
            authorised_value    => 'Not enoug budget',
            lib                 => 'This book it too much expensive',
        }
    ]
);

my %fielddefinitions = (
# fieldname => [
#    {          field => 'fieldname',
#             type    => 'fieldtype',
#             null    => '',
#             key     => '',
#             default => ''
#         },
#     ],
    aqbasket =>  [
        {
            field    => 'booksellerid',
            type    => 'int(11)',
            null    => 'NOT NULL',
            key        => '',
            default    => '1',
            extra    => '',
        },
    ],
    aqbooksellers =>  [
        {
            field    => 'id',
            type    => 'int(11)',
            null    => 'NOT NULL',
            key        => '',
            default    => '',
            extra    => 'auto_increment',
        },
        {
            field    => 'listprice',
            type    => 'varchar(10)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'invoiceprice',
            type    => 'varchar(10)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
    ],
    
    accountlines =>  [
        {
            field    => 'notify_id',
            type    => 'int(11)',
            null    => 'NOT NULL',
            key        => '',
            default    => '0',
            extra    => '',
        },
        {
            field    => 'notify_level',
            type    => 'int(2)',
            null    => 'NOT NULL',
            key        => '',
            default    => '0',
            extra    => '',
        },
    
    ],
    
    borrowers => [
        {    field => 'firstname',
             type => 'text',
             null => 'NULL',
         },
        {    field => 'initials',
             type => 'text',
             null => 'NULL',
         },
        {    field => 'B_email',
             type => 'text',
             null => 'NULL',
             after => 'B_zipcode',
         },
         {
            field => 'streetnumber', # street number (hidden if streettable table is empty)
            type => 'char(10)',
            null => 'NULL',
            after => 'initials',
        },
        {
            field => 'streettype', # street table, list builded from a system table
            type => 'char(50)',
            null => 'NULL',
            after => 'streetnumber',
        },
        {    field => 'phone',
             type => 'text',
             null => 'NULL',
         },
        {
            field => 'B_streetnumber', # street number (hidden if streettable table is empty)
            type => 'char(10)',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'B_streettype', # street table, list builded from a system table
            type => 'char(50)',
            null => 'NULL',
            after => 'B_streetnumber',
        },
        {
            field => 'phonepro',
            type => 'text',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'address2', # complement address
            type => 'text',
            null => 'NULL',
            after => 'address',
        },
        {
            field => 'emailpro',
            type => 'text',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'contactfirstname', # contact's firstname
            type => 'text',
            null => 'NULL',
            after => 'contactname',
        },
        {
            field => 'contacttitle', # contact's title
            type => 'text',
            null => 'NULL',
            after => 'contactfirstname',
        },
        {
            field => 'branchcode',
            type  => 'varchar(10)',
            null  => 'NOT NULL',
            default    => '',
            extra => '',
        },
        {
            field => 'categorycode',
            type  => 'varchar(10)',
            null  => 'NOT NULL',
            default    => '',
            extra => '',
        }
    ],
    
    biblioitems =>  [
        {
            field    => 'lcsort',
            type    => 'varchar(25)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'ccode',
            type    => 'varchar(4)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
    ],
    branches =>  [
        {
            field    => 'branchip',
            type    => 'varchar(15)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'branchprinter',
            type    => 'varchar(100)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field   => 'branchcode',
            type    => 'varchar(10)',
            null    => 'NOT NULL',
            default => '',
            extra   => '',
        }
    ],
    branchtransfers =>[
        {
            field   => 'frombranch',
            type    => 'VARCHAR(10)',
            null    => 'NOT NULL',
            key     => '',
            default => '',
            extra   => '',
        },
        {
            field   => 'tobranch',
            type    => 'VARCHAR(10)',
            null    => 'NOT NULL',
            key     => '',
            default => '',
        }
    ],
    
    categories =>  [
        {
            field    => 'category_type',
            type    => 'char(1)',
            null    => 'NOT NULL',
            key        => '',
            default    => 'A',
            extra    => '',
        },
        {
            field   => 'categorycode',
            type    => 'varchar(10)',
            null    => 'NOT NULL',
            key     => 'PRI',
            default => '',
            extra   => '',
        },
    ],
    
    deletedborrowers => [
        {    field => 'firstname',
             type => 'text',
             null => 'NULL',
         },
        {    field => 'initials',
             type => 'text',
             null => 'NULL',
         },
        {    field => 'B_email',
             type => 'text',
             null => 'NULL',
             after => 'B_zipcode',
         },
         {
            field => 'streetnumber', # street number (hidden if streettable table is empty)
            type => 'char(10)',
            null => 'NULL',
            after => 'initials',
        },
        {
            field => 'streettype', # street table, list builded from a system table
            type => 'char(50)',
            null => 'NULL',
            after => 'streetnumber',
        },
        {    field => 'phone',
             type => 'text',
             null => 'NULL',
         },
         {
            field => 'B_streetnumber', # street number (hidden if streettable table is empty)
            type => 'char(10)',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'B_streettype', # street table, list builded from a system table
            type => 'char(50)',
            null => 'NULL',
            after => 'B_streetnumber',
        },
        {
            field => 'phonepro',
            type => 'text',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'address2', # complement address
            type => 'text',
            null => 'NULL',
            after => 'address',
        },
        {
            field => 'emailpro',
            type => 'text',
            null => 'NULL',
            after => 'fax',
        },
        {
            field => 'contactfirstname', # contact's firstname
            type => 'text',
            null => 'NULL',
            after => 'contactname',
        },
        {
            field => 'contacttitle', # contact's title
            type => 'text',
            null => 'NULL',
            after => 'contactfirstname',
        },
    ],
    
    issues =>  [
        {
            field    => 'borrowernumber',
            type    => 'int(11)',
            null    => 'NULL', # can be null when a borrower is deleted and the foreign key rule executed
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'itemnumber',
            type    => 'int(11)',
            null    => 'NULL', # can be null when a borrower is deleted and the foreign key rule executed
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field   => 'branchcode',
            type    => 'varchar(10)',
            null    => 'NULL',
            key     => '',
            default => '',
            extra   => '',
        },
        {
            field   => 'issuedate',
            type    => 'date',
            null    => '',
            key     => '',
            default => '0000-00-00',
            extra   => '',
        },
    ],
    
    items => [
        {
            field    => 'onloan',
            type    => 'date',
            null    => 'NULL',
            key        => '',
            default    => '0000-00-00',
            extra    => '',
        },
        {
            field    => 'cutterextra',
            type    => 'varchar(45)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'issue_date',
            type    => 'date',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'holdingbranch',
            type    => 'varchar(10)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'itype',
            type    => 'varchar(10)',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
    ],
    itemtypes => [
        {
            field  => 'itemtype',
            type   => 'varchar(10)',
            default    => '',
            null   => 'NOT NULL',
            key    => 'PRI',
            extra  => 'UNIQUE',
        },
        {
            field  => 'summary',
            type   => 'TEXT',
            null   => 'NULL',
            key    => '',
            extra  => '',
        },
    ],
    opac_news => [
        {
            field  => 'expirationdate',
            type   => 'date',
            null   => 'null',
            key    => '',
            extra  => '',
        },
        {
            field   => 'number',
            type    => 'int(11)',
            null    => 'NULL',
            key     => '',
            default => '0',
            extra   => '',
        },
    ],
    reserves =>  [
        {
            field    => 'waitingdate',
            type    => 'date',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
    ],
    serial => [
        {
            field   => 'notes',
            type    => 'TEXT',
            null    => 'NULL',
            key     => '',
            default => '',
            extra   => ''
        },
    ],
    shelfcontents => [
        {
            field => 'dateadded',
            type => 'timestamp',
            null    => 'NULL',
        },
    ],
    systempreferences =>  [
        {
            field    => 'value',
            type    => 'text',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
        {
            field    => 'explanation',
            type    => 'text',
            null    => 'NULL',
            key        => '',
            default    => '',
            extra    => '',
        },
    ],
    suggestions => [
        {
            field   => 'reason',
            type    => 'text',
            null    => 'NULL',
            key     => ''  ,
            default => '',
            extra   =>    '',
        }
    ],
);

my %indexes = (
#    table => [
#         {    indexname => 'index detail'
#         }
#    ],
    aqbooksellers => [
        {    indexname => 'PRIMARY',
            content => 'id',
            type => 'PRI',
        }
    ],
    aqbasket => [
        {    indexname => 'booksellerid',
            content => 'booksellerid',
        },
    ],
    aqorders => [
        {    indexname => 'basketno',
            content => 'basketno',
        },
    ],
    aqorderbreakdown => [
        {    indexname => 'ordernumber',
            content => 'ordernumber',
        },
        {    indexname => 'bookfundid',
            content => 'bookfundid',
        },
    ],
    biblioitems => [
        {    indexname => 'isbn',
            content => 'isbn',
        },
        {    indexname => 'publishercode',
            content => 'publishercode',
        },
    ],
    branches => [
        {
            indexname => 'branchcode',
            content   => 'branchcode',
    
        }
    ],
    currency => [
        {    indexname => 'PRIMARY',
            content => 'currency',
            type => 'PRI',
        }
    ],
    categories => [
        {
            indexname => 'categorycode',
            content   => 'categorycode',
        }
    ],
    items => [
        {    indexname => 'homebranch',
            content => 'homebranch',
        },
        {    indexname => 'holdingbranch',
            content => 'holdingbranch',
        }
    ],
    itemtypes => [
        {
            indexname => 'itemtype',
            content   => 'itemtype',
        }
    ],
    shelfcontents => [
        {    indexname => 'shelfnumber',
            content => 'shelfnumber',
        },
        {    indexname => 'itemnumber',
            content => 'itemnumber',
        }
    ],
);

my %foreign_keys = (
#    table => [
#         {    key => 'the key in table' (must be indexed)
#            foreigntable => 'the foreigntable name', # (the parent)
#            foreignkey => 'the foreign key column(s)' # (in the parent)
#            onUpdate => 'CASCADE|SET NULL|NO ACTION| RESTRICT',
#            onDelete => 'CASCADE|SET NULL|NO ACTION| RESTRICT',
#         }
#    ],
    shelfcontents => [
        {    key => 'shelfnumber',
            foreigntable => 'bookshelf',
            foreignkey => 'shelfnumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemnumber',
            foreigntable => 'items',
            foreignkey => 'itemnumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    # onDelete is RESTRICT on reference tables (branches, itemtype) as we don't want items to be
    # easily deleted, but branches/itemtype not too easy to empty...
    biblioitems => [
        {    key => 'biblionumber',
            foreigntable => 'biblio',
            foreignkey => 'biblionumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemtype',
            foreigntable => 'itemtypes',
            foreignkey => 'itemtype',
            onUpdate => 'CASCADE',
            onDelete => 'RESTRICT',
        },
    ],
    items => [
        {    key => 'biblioitemnumber',
            foreigntable => 'biblioitems',
            foreignkey => 'biblioitemnumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'homebranch',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'CASCADE',
            onDelete => 'RESTRICT',
        },
        {    key => 'holdingbranch',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'CASCADE',
            onDelete => 'RESTRICT',
        },
    ],
    aqbasket => [
        {    key => 'booksellerid',
            foreigntable => 'aqbooksellers',
            foreignkey => 'id',
            onUpdate => 'CASCADE',
            onDelete => 'RESTRICT',
        },
    ],
    aqorders => [
        {    key => 'basketno',
            foreigntable => 'aqbasket',
            foreignkey => 'basketno',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'biblionumber',
            foreigntable => 'biblio',
            foreignkey => 'biblionumber',
            onUpdate => 'SET NULL',
            onDelete => 'SET NULL',
        },
    ],
    aqbooksellers => [
        {    key => 'listprice',
            foreigntable => 'currency',
            foreignkey => 'currency',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'invoiceprice',
            foreigntable => 'currency',
            foreignkey => 'currency',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    aqorderbreakdown => [
        {    key => 'ordernumber',
            foreigntable => 'aqorders',
            foreignkey => 'ordernumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'bookfundid',
            foreigntable => 'aqbookfund',
            foreignkey => 'bookfundid',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    branchtransfers => [
        {    key => 'frombranch',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'tobranch',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemnumber',
            foreigntable => 'items',
            foreignkey => 'itemnumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    issuingrules => [
        {    key => 'categorycode',
            foreigntable => 'categories',
            foreignkey => 'categorycode',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemtype',
            foreigntable => 'itemtypes',
            foreignkey => 'itemtype',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    issues => [    # constraint is SET NULL : when a borrower or an item is deleted, we keep the issuing record
    # for stat purposes
        {    key => 'borrowernumber',
            foreigntable => 'borrowers',
            foreignkey => 'borrowernumber',
            onUpdate => 'SET NULL',
            onDelete => 'SET NULL',
        },
        {    key => 'itemnumber',
            foreigntable => 'items',
            foreignkey => 'itemnumber',
            onUpdate => 'SET NULL',
            onDelete => 'SET NULL',
        },
    ],
    reserves => [
        {    key => 'borrowernumber',
            foreigntable => 'borrowers',
            foreignkey => 'borrowernumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'biblionumber',
            foreigntable => 'biblio',
            foreignkey => 'biblionumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemnumber',
            foreigntable => 'items',
            foreignkey => 'itemnumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'branchcode',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    borrowers => [ # foreign keys are RESTRICT as we don't want to delete borrowers when a branch is deleted
    # but prevent deleting a branch as soon as it has 1 borrower !
        {    key => 'categorycode',
            foreigntable => 'categories',
            foreignkey => 'categorycode',
            onUpdate => 'RESTRICT',
            onDelete => 'RESTRICT',
        },
        {    key => 'branchcode',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'RESTRICT',
            onDelete => 'RESTRICT',
        },
    ],
    deletedborrowers => [ # foreign keys are RESTRICT as we don't want to delete borrowers when a branch is deleted
    # but prevent deleting a branch as soon as it has 1 borrower !
        {    key => 'categorycode',
            foreigntable => 'categories',
            foreignkey => 'categorycode',
            onUpdate => 'RESTRICT',
            onDelete => 'RESTRICT',
        },
        {    key => 'branchcode',
            foreigntable => 'branches',
            foreignkey => 'branchcode',
            onUpdate => 'RESTRICT',
            onDelete => 'RESTRICT',
        },
    ],
    accountlines => [
        {    key => 'borrowernumber',
            foreigntable => 'borrowers',
            foreignkey => 'borrowernumber',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
        {    key => 'itemnumber',
            foreigntable => 'items',
            foreignkey => 'itemnumber',
            onUpdate => 'SET NULL',
            onDelete => 'SET NULL',
        },
    ],
    auth_tag_structure => [
        {    key => 'authtypecode',
            foreigntable => 'auth_types',
            foreignkey => 'authtypecode',
            onUpdate => 'CASCADE',
            onDelete => 'CASCADE',
        },
    ],
    # FIXME : don't constraint auth_*_table and auth_word, as they may be replaced by zebra
);


# column changes
my %column_change = (
    # table
    borrowers => [
                {
                    from => 'emailaddress',
                    to => 'email',
                    after => 'city',
                },
                {
                    from => 'streetaddress',
                    to => 'address',
                    after => 'initials',
                },
                {
                    from => 'faxnumber',
                    to => 'fax',
                    after => 'phone',
                },
                {
                    from => 'textmessaging',
                    to => 'opacnote',
                    after => 'userid',
                },
                {
                    from => 'altnotes',
                    to => 'contactnote',
                    after => 'opacnote',
                },
                {
                    from => 'physstreet',
                    to => 'B_address',
                    after => 'fax',
                },
                {
                    from => 'streetcity',
                    to => 'B_city',
                    after => 'B_address',
                },
                {
                    from => 'phoneday',
                    to => 'mobile',
                    after => 'phone',
                },
                {
                    from => 'zipcode',
                    to => 'zipcode',
                    after => 'city',
                },
                {
                    from => 'homezipcode',
                    to => 'B_zipcode',
                    after => 'B_city',
                },
                {
                    from => 'altphone',
                    to => 'B_phone',
                    after => 'B_zipcode',
                },
                {
                    from => 'expiry',
                    to => 'dateexpiry',
                    after => 'dateenrolled',
                },
                {
                    from => 'guarantor',
                    to => 'guarantorid',
                    after => 'contactname',
                },
                {
                    from => 'altrelationship',
                    to => 'relationship',
                    after => 'borrowernotes',
                },
            ],

    deletedborrowers => [
                {
                    from => 'emailaddress',
                    to => 'email',
                    after => 'city',
                },
                {
                    from => 'streetaddress',
                    to => 'address',
                    after => 'initials',
                },
                {
                    from => 'faxnumber',
                    to => 'fax',
                    after => 'phone',
                },
                {
                    from => 'textmessaging',
                    to => 'opacnote',
                    after => 'userid',
                },
                {
                    from => 'altnotes',
                    to => 'contactnote',
                    after => 'opacnote',
                },
                {
                    from => 'physstreet',
                    to => 'B_address',
                    after => 'fax',
                },
                {
                    from => 'streetcity',
                    to => 'B_city',
                    after => 'B_address',
                },
                {
                    from => 'phoneday',
                    to => 'mobile',
                    after => 'phone',
                },
                {
                    from => 'zipcode',
                    to => 'zipcode',
                    after => 'city',
                },
                {
                    from => 'homezipcode',
                    to => 'B_zipcode',
                    after => 'B_city',
                },
                {
                    from => 'altphone',
                    to => 'B_phone',
                    after => 'B_zipcode',
                },
                {
                    from => 'expiry',
                    to => 'dateexpiry',
                    after => 'dateenrolled',
                },
                {
                    from => 'guarantor',
                    to => 'guarantorid',
                    after => 'contactname',
                },
                {
                    from => 'altrelationship',
                    to => 'relationship',
                    after => 'borrowernotes',
                },
            ],
        );
    

# MOVE all tables TO UTF-8 and innoDB
$sth = $dbh->prepare("show table status");
$sth->execute;
while ( my $table = $sth->fetchrow_hashref ) {
     if ($table->{Engine} ne 'InnoDB') {
         $dbh->do("ALTER TABLE $table->{Name} TYPE = innodb");
         print "moving $table->{Name} to InnoDB\n";
     }
    next if $table->{Name} eq 'marc_word';
    next if $table->{Name} eq 'marc_subfield_table';
    next if $table->{Name} eq 'auth_word';
    next if $table->{Name} eq 'auth_subfield_table';
    unless ($table->{Collation} =~ /^utf8/) {
         print "moving $table->{Name} to utf8\n";
        $dbh->do("ALTER TABLE $table->{Name} CONVERT TO CHARACTER SET utf8");
        $dbh->do("ALTER TABLE $table->{Name} DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci");
        # FIXME : maybe a ALTER TABLE tbl_name CONVERT TO CHARACTER SET utf8 would be better, def char set seems to work fine. If any problem encountered, let's try with convert !
    } else {
    }
}


foreach my $table (keys %column_change) {
    $sth = $dbh->prepare("show columns from $table");
    $sth->execute();
    undef %types;
    while ( ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow )
    {
        $types{$column}->{type} ="$type";
        $types{$column}->{null} = "$null";
        $types{$column}->{key} = "$key";
        $types{$column}->{default} = "$default";
        $types{$column}->{extra} = "$extra";
    }    # while
    my $tablerows = $column_change{$table};
    foreach my $row ( @$tablerows ) {
        if ($types{$row->{from}}->{type}) {
            print "altering $table $row->{from} to $row->{to}\n";
            # ALTER TABLE `borrowers` CHANGE `faxnumber` `fax` TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL
#             alter table `borrowers` change `faxnumber` `fax` type text  null after phone
            my $sql =
                "alter table `$table` change `$row->{from}` `$row->{to}` $types{$row->{from}}->{type} ".
                ($types{$row->{from}}->{null} eq 'YES'?" NULL":" NOT NULL").
                ($types{$row->{from}}->{default}?" default ".$types{$row->{from}}->{default}:"").
                "$types{$row->{from}}->{extra} after $row->{after} ";
#             print "$sql";
            $dbh->do($sql);
        }
    }
}

# Enter here the field you want to delete from DB.
# FIXME :: there is a %uselessfield before which seems doing the same things.
my %fieldtodelete = (
    # tablename => [fieldname1,fieldname2,...]

); # %fielddelete

print "removing some unused fields...\n";
foreach my $table ( keys %fieldtodelete ) {
    foreach my $field ( @{$fieldtodelete{$table}} ){
        print "removing ".$field." from ".$table;
        my $sth = $dbh->prepare("ALTER TABLE $table DROP $field");
        $sth->execute;
        if ( $sth->err ) {
            print "Error : $sth->errstr \n";
        }
    }
}

# Enter here the line you want to remove from DB.
my %linetodelete = (
    # table name => where clause.
    userflags => "bit = 8", # delete the 'reserveforself' flags
    
); # %linetodelete

#-------------------
# Initialize

# Start checking

# Get version of MySQL database engine.
my $mysqlversion = `mysqld --version`;
$mysqlversion =~ /Ver (\S*) /;
$mysqlversion = $1;
if ( $mysqlversion ge '3.23' ) {
    print "Could convert to MyISAM database tables...\n" unless $silent;
}

#---------------------------------
# Tables

# Collect all tables into a list
$sth = $dbh->prepare("show tables");
$sth->execute;
while ( my ($table) = $sth->fetchrow ) {
    $existingtables{$table} = 1;
}


# Now add any missing tables
foreach $table ( keys %requiretables ) {
    unless ( $existingtables{$table} ) {
    print "Adding $table table...\n" unless $silent;
        my $sth = $dbh->prepare("create table $table $requiretables{$table}");
        $sth->execute;
        if ( $sth->err ) {
            print "Error : $sth->errstr \n";
            $sth->finish;
        }    # if error
    }    # unless exists
}    # foreach

#---------------------------------
# Columns

foreach $table ( keys %requirefields ) {
    print "Check table $table\n" if $debug and not $silent;
    $sth = $dbh->prepare("show columns from $table");
    $sth->execute();
    undef %types;
    while ( ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow )
    {
        $types{$column} = $type;
    }    # while
    foreach $column ( keys %{ $requirefields{$table} } ) {
        print "  Check column $column  [$types{$column}]\n" if $debug and not $silent;
        if ( !$types{$column} ) {

            # column doesn't exist
            print "Adding $column field to $table table...\n" unless $silent;
            $query = "alter table $table
            add column $column " . $requirefields{$table}->{$column};
            print "Execute: $query\n" if $debug;
            my $sti = $dbh->prepare($query);
            $sti->execute;
            if ( $sti->err ) {
                print "**Error : $sti->errstr \n";
                $sti->finish;
            }    # if error
        }    # if column
    }    # foreach column
}    # foreach table

foreach $table ( keys %fielddefinitions ) {
    print "Check table $table\n" if $debug;
    $sth = $dbh->prepare("show columns from $table");
    $sth->execute();
    my $definitions;
    while ( ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow )
    {
        $definitions->{$column}->{type}    = $type;
        $definitions->{$column}->{null}    = $null;
        $definitions->{$column}->{null}    = 'NULL' if $null eq 'YES';
        $definitions->{$column}->{key}     = $key;
        $definitions->{$column}->{default} = $default;
        $definitions->{$column}->{extra}   = $extra;
    }    # while
    my $fieldrow = $fielddefinitions{$table};
    foreach my $row (@$fieldrow) {
        my $field   = $row->{field};
        my $type    = $row->{type};
        my $null    = $row->{null};
#         $null    = 'YES' if $row->{null} eq 'NULL';
        my $key     = $row->{key};
        my $default = $row->{default};
#         $default="''" unless $default;
        my $extra   = $row->{extra};
        my $def     = $definitions->{$field};
        my $after    = ($row->{after}?" after ".$row->{after}:"");

        unless ( $type eq $def->{type}
            && $null eq $def->{null}
            && $key eq $def->{key}
            && $extra eq $def->{extra} )
        {
            if ( $null eq '' ) {
                $null = 'NOT NULL';
            }
            if ( $key eq 'PRI' ) {
                $key = 'PRIMARY KEY';
            }
            unless ( $extra eq 'auto_increment' ) {
                $extra = '';
            }
    
            # if it's a new column use "add", if it's an old one, use "change".
            my $action;
            if ($definitions->{$field}->{type}) {
                $action="change $field"
            } else {
                $action="add";
            }
# if it's a primary key, drop the previous pk, before altering the table
            my $sth;
            if ($key ne 'PRIMARY KEY') {
#                 warn "alter table $table $action $field $type $null $key $extra default $default $after";
                $sth =$dbh->prepare("alter table $table $action $field $type $null $key $extra default ? $after");
            } else {
#             warn "alter table $table drop primary key, $action $field $type $null $key $extra default $default $after";
                 # something strange : for indexes UNIQUE, they are reported as primary key here.
                 # but if you try to run with drop primary key, it fails.
                 # thus, we run the query twice, one will fail, one will succeed.
                 # strange...
                $sth =$dbh->prepare("alter table $table drop primary key, $action $field $type $null $key $extra default ? $after");
                $sth =$dbh->prepare("alter table $table $action $field $type $null $key $extra default ? $after");
            }
# ALTER TABLE `borrowers` CHANGE `branchcode` `branchcode` VARCHAR( 10 ) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL 
            print "  alter or create $field in $table\n" unless $silent;
            $sth->execute($default);
        }
    }
}

print "removing some unused data...\n";
foreach my $table ( keys %linetodelete ) {
    foreach my $where ( @{linetodelete{$table}} ){
        print "DELETE FROM ".$table." where ".$where;
        print "\n";
        my $sth = $dbh->prepare("DELETE FROM $table where $where");
        $sth->execute;
        if ( $sth->err ) {
            print "Error : $sth->errstr \n";
        }
    }
}

# Populate tables with required data

# synch table and deletedtable.
foreach my $table (('borrowers','items','biblio','biblioitems')) {
    my %deletedborrowers;
    print "synch'ing $table and deleted$table\n";
    $sth = $dbh->prepare("show columns from deleted$table");
    $sth->execute;
    while ( my ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow ) {
        $deletedborrowers{$column}=1;
    }
    $sth = $dbh->prepare("show columns from $table");
    $sth->execute;
    my $previous;
    while ( my ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow ) {
        unless ($deletedborrowers{$column}) {
            my $newcol="alter table deleted$table add $column $type";
            if ($null eq 'YES') {
                $newcol .= " NULL ";
            } else {
                $newcol .= " NOT NULL ";
            }
            $newcol .= "default ".$dbh->quote($default) if $default;
            $newcol .= " after $previous" if $previous;
            $previous=$column;
            print "creating column $column\n";
            $dbh->do($newcol);
        }
    }
}
#
# update publisheddate 
#
$sth = $dbh->prepare("select count(*) from serial where publisheddate is NULL");
$sth->execute;
my ($emptypublished) = $sth->fetchrow;
if ($emptypublished) {
    print "Updating publisheddate\n";
    $dbh->do("update serial set publisheddate=planneddate where publisheddate is NULL");
}
foreach my $table ( keys %tabledata ) {
    print "Checking for data required in table $table...\n" unless $silent;
    my $tablerows = $tabledata{$table};
    foreach my $row (@$tablerows) {
        my $uniquefieldrequired = $row->{uniquefieldrequired};
        my $uniquevalue         = $row->{$uniquefieldrequired};
        my $forceupdate         = $row->{forceupdate};
        my $sth                 =
          $dbh->prepare(
"select $uniquefieldrequired from $table where $uniquefieldrequired=?"
        );
        $sth->execute($uniquevalue);
        if ($sth->rows) {
            foreach my $field (keys %$forceupdate) {
                if ($forceupdate->{$field}) {
                    my $sth=$dbh->prepare("update systempreferences set $field=? where $uniquefieldrequired=?");
                    $sth->execute($row->{$field}, $uniquevalue);
                }
            }
        } else {
            print "Adding row to $table: " unless $silent;
            my @values;
            my $fieldlist;
            my $placeholders;
            foreach my $field ( keys %$row ) {
                next if $field eq 'uniquefieldrequired';
                next if $field eq 'forceupdate';
                my $value = $row->{$field};
                push @values, $value;
                print "  $field => $value" unless $silent;
                $fieldlist .= "$field,";
                $placeholders .= "?,";
            }
            print "\n" unless $silent;
            $fieldlist    =~ s/,$//;
            $placeholders =~ s/,$//;
            print "insert into $table ($fieldlist) values ($placeholders)";
            my $sth =
            $dbh->prepare(
                "insert into $table ($fieldlist) values ($placeholders)");
            $sth->execute(@values);
        }
    }
}

#
# check indexes and create them when needed
#
print "Checking for index required...\n" unless $silent;
foreach my $table ( keys %indexes ) {
    #
    # read all indexes from $table
    #
    $sth = $dbh->prepare("show index from $table");
    $sth->execute;
    my %existingindexes;
    while ( my ( $table, $non_unique, $key_name, $Seq_in_index, $Column_name, $Collation, $cardinality, $sub_part, $Packed, $comment ) = $sth->fetchrow ) {
        $existingindexes{$key_name} = 1;
    }
    # read indexes to check
    my $tablerows = $indexes{$table};
    foreach my $row (@$tablerows) {
        my $key_name=$row->{indexname};
        if ($existingindexes{$key_name} eq 1) {
#             print "$key_name existing";
        } else {
            print "\tCreating index $key_name in $table\n";
            my $sql;
            if ($row->{indexname} eq 'PRIMARY') {
                $sql = "alter table $table ADD PRIMARY KEY ($row->{content})";
            } else {
                $sql = "alter table $table ADD INDEX $key_name ($row->{content}) $row->{type}";
            }
             $dbh->do($sql);
            print "Error $sql : $dbh->err \n" if $dbh->err;
        }
    }
}

#
# check foreign keys and create them when needed
#
print "Checking for foreign keys required...\n" unless $silent;
foreach my $table ( keys %foreign_keys ) {
    #
    # read all indexes from $table
    #
    $sth = $dbh->prepare("show table status like '$table'");
    $sth->execute;
    my $stat = $sth->fetchrow_hashref;
    # read indexes to check
    my $tablerows = $foreign_keys{$table};
    foreach my $row (@$tablerows) {
        my $foreign_table=$row->{foreigntable};
        if ($stat->{'Comment'} =~/$foreign_table/) {
#             print "$foreign_table existing\n";
        } else {
            print "\tCreating foreign key $foreign_table in $table\n";
            # first, drop any orphan value in child table
            if ($row->{onDelete} ne "RESTRICT") {
                my $sql = "delete from $table where $row->{key} not in (select $row->{foreignkey} from $row->{foreigntable})";
                $dbh->do($sql);
                print "SQL ERROR: $sql : $dbh->err \n" if $dbh->err;
            }
            my $sql="alter table $table ADD FOREIGN KEY $row->{key} ($row->{key}) REFERENCES $row->{foreigntable} ($row->{foreignkey})";
            $sql .= " on update ".$row->{onUpdate} if $row->{onUpdate};
            $sql .= " on delete ".$row->{onDelete} if $row->{onDelete};
            $dbh->do($sql);
            if ($dbh->err) {
                print "====================
An error occured during :
\t$sql
It probably means there is something wrong in your DB : a row ($table.$row->{key}) refers to a value in $row->{foreigntable}.$row->{foreignkey} that does not exist. solve the problem and run updater again (or just the previous SQL statement).
You can find those values with select
\t$table.* from $table where $row->{key} not in (select $row->{foreignkey} from $row->{foreigntable})
====================\n
";
            }
        }
    }
}
# now drop useless tables
foreach $table ( @TableToDelete ) {
    if ( $existingtables{$table} ) {
        print "Dropping unused table $table\n" if $debug and not $silent;
        $dbh->do("drop table $table");
        if ( $dbh->err ) {
            print "Error : $dbh->errstr \n";
        }
    }
}

#
# SPECIFIC STUFF
#
#
# create frameworkcode row in biblio table & fill it with marc_biblio.frameworkcode.
#

# 1st, get how many biblio we will have to do...
$sth = $dbh->prepare('select count(*) from marc_biblio');
$sth->execute;
my ($totaltodo) = $sth->fetchrow;

$sth = $dbh->prepare("show columns from biblio");
$sth->execute();
my $definitions;
my $bibliofwexist=0;
while ( ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow ){
    $bibliofwexist=1 if $column eq 'frameworkcode';
}
unless ($bibliofwexist) {
    print "moving biblioframework to biblio table\n";
    $dbh->do('ALTER TABLE `biblio` ADD `frameworkcode` VARCHAR( 4 ) NOT NULL AFTER `biblionumber`');
    $sth = $dbh->prepare('select biblionumber,frameworkcode from marc_biblio');
    $sth->execute;
    my $sth_update = $dbh->prepare('update biblio set frameworkcode=? where biblionumber=?');
    my $totaldone=0;
    while (my ($biblionumber,$frameworkcode) = $sth->fetchrow) {
        $sth_update->execute($frameworkcode,$biblionumber);
        $totaldone++;
        print "\r$totaldone / $totaltodo" unless ($totaldone % 100);
    }
    print "\rdone\n";
}

# at last, remove useless fields
foreach $table ( keys %uselessfields ) {
    my @fields = split /,/,$uselessfields{$table};
    my $fields;
    my $exists;
    foreach my $fieldtodrop (@fields) {
        $fieldtodrop =~ s/\t//g;
        $fieldtodrop =~ s/\n//g;
        $exists =0;
        $sth = $dbh->prepare("show columns from $table");
        $sth->execute;
        while ( my ( $column, $type, $null, $key, $default, $extra ) = $sth->fetchrow )
        {
            $exists =1 if ($column eq $fieldtodrop);
        }
        if ($exists) {
            print "deleting $fieldtodrop field in $table...\n" unless $silent;
            my $sth = $dbh->prepare("alter table $table drop $fieldtodrop");
            $sth->execute;
        }
    }
}    # foreach

#
# Changing aqbookfund's primary key 
#
$sth=$dbh->prepare("ALTER TABLE `aqbookfund` DROP PRIMARY KEY , ADD PRIMARY KEY ( `bookfundid` , `branchcode` ) ;");
$sth->execute;

$sth->finish;

exit;

# $Log$
# Revision 1.158  2007/03/09 15:14:57  tipaul
# rel_3_0 moved to HEAD
#
# Revision 1.157.2.56  2007/01/31 16:22:54  btoumi
# -add possibility to use isbn with length of 13 characters
# for  Import datas in the reservoir.
# -modify isbn field in marc_breeding table (varchar 13)
# -add isbn filter (no - )when u read a notice from reservoir
# -add filter to have right field 100
#
# Revision 1.157.2.55  2007/01/30 10:50:19  tipaul
# adding 2 usefull indexes to biblioitems table
#
# Revision 1.157.2.54  2007/01/29 16:45:52  toins
# * adding a new default authorised value : SUGGEST.
# SUGGEST give some reasons to accept or reject a suggestion.
#
# * default value for borrowersMandatoryfield syspref is now "cardnumber|surname|adress"
#
# Revision 1.157.2.53  2007/01/26 20:48:37  hdl
# Serials management : Bugfixes + improvements.
# - Partial dates are now managed
# - next Date Calculation with irregularity tested for 1 week and 1 month.
# - manage if subscription is abouttoexpire or expired.
# - Adding some information on serials pages about subscription.
# - Managing irregularity with numbers.
# - Adding Internal Notes in subscription management.
# - Repeating Button above pages.
#
# Please run Updatedatabase to change irregularity and add internalnotes field  to subscription
#
# Revision 1.157.2.52  2007/01/24 13:57:26  tipaul
# - setting supplierid to auto_increment (HDL : could you check that is works, i'm not 100% sure)
# - removing 22 -> 30 marc_subfield_table -> marcxml stuff, it's now in misc/migration_tools/22_to_30/
#
# Revision 1.157.2.51  2007/01/18 09:58:45  tipaul
# defaulting NOT NULL fields (to '')
#
# Revision 1.157.2.50  2007/01/18 09:39:21  tipaul
# issuedate must be defaulted with ' '
#
# Revision 1.157.2.49  2007/01/18 09:37:30  tipaul
# removing 2 field definitions that were here twice
#
# Revision 1.157.2.48  2007/01/15 09:55:40  toins
# adding a new logging systempref : FinesLog.
#
# Revision 1.157.2.47  2007/01/12 18:09:49  toins
# LetterLog added
#
# Revision 1.157.2.46  2007/01/11 14:35:39  tipaul
# adding Opac Browser feature : the build_browser_and_cloud.pl script will :
# - fill the browser table, that enable browsing, digit by digit of a given category, the catalogue. A complete dewey classification is provided in the script, active only for french libraries, of course (although, for instance, the script check that the catalogue is in english for developping convenience)
# - fill the tags table, that contains the subject cloud.
#
# The cloud part is a copy of the previous build_tags.pl script that can be deleted : those 2 scripts require to parse all the catalogue to extract interesting data, so they are long. It's useless to parse the catalogue twice !
#
# The commit also add the systempreference to hide/show the OpacBrowse in database & in systempref management script.
#
# IMPROVEMENTS to do :
# - the script that builds the tables can be improved to update only last week biblios (at the price of a small error in value links, but it's not a problem).
# - add, in parameters section, a place to edit browser descriptions. The build script has to be updated to to avoid deleting existing browser descriptions.
#
# Revision 1.157.2.45  2007/01/10 16:52:52  toins
# Value for Log Features syspref are set to 0 by default.
#
# Revision 1.157.2.44  2007/01/10 16:31:15  toins
# new systems preferences :
#  - CataloguingLog (log the update/creation/deletion of a notice if set to 1)
#  - BorrowersLog ( idem for borrowers )
#  - IssueLog (log all issue if set to 1)
#  - ReturnLog (log all return if set to 1)
#  - SusbcriptionLog (log all creation/deletion/update of a subcription)
#
# All of theses are in a new tab called 'LOGFeatures' in systempreferences.pl
#
# Revision 1.157.2.43  2007/01/10 14:13:17  toins
# opac_news.displayed is replaced by opac_news.number.
# This field say how are ordered the news on the template.
#
# Revision 1.157.2.42  2007/01/09 14:09:01  toins
# 2 field added to opac_news.('expirationdate' and 'displayed').
#
# Revision 1.157.2.41  2006/12/22 17:11:33  tipaul
# adding 3 systempreferences for opac features & a new systempref tab where all systempreferences are located
#
# Revision 1.157.2.40  2006/12/20 16:45:59  tipaul
# ZEBRA update :
# - adding a new table : when a biblio is added/modified/ deleted, an entry is entered in this table
# - the zebraqueue_start.pl script read it & does the stuff.
#
# code coming from head (tumer). it can be run every minut instead of once every day for dev_week code.
#
# I just have commented the previous code (=real time update) in Biblio.pm, we will be able to reactivate it once indexdata fixes zebra update bug !
#
# Revision 1.157.2.39  2006/12/20 11:42:17  toins
# adding table "tags"
#
# Revision 1.157.2.38  2006/12/19 12:06:53  alaurin
# adding a new system preference : RequestOnOpac ;
#
# adding update database
#
# Revision 1.157.2.37  2006/12/19 10:49:21  toins
# fix a minor bug in syspref "expandedSearchOption" and adding it on updatedatabase.
#
# Revision 1.157.2.36  2006/12/13 19:48:09  hdl
# Adding claimdate to serials.
# (Needed to record claimdate
#
# Revision 1.157.2.35  2006/12/08 15:36:57  hdl
# Adding issuedate to issues table.
#
# Revision 1.157.2.34  2006/12/07 16:00:41  hdl
# Adding issuedate to table issues.
# Modifying issuedate on issue (Circ2.pm)
# Modifying report issue_avg_stats to take this change into account. (Need TESTING)
#
# Revision 1.157.2.33  2006/12/06 14:12:18  btoumi
# add BorrowersTitles systempreferences to setup borrowers title
#
# Revision 1.157.2.32  2006/12/06 13:49:41  toins
# deleting additionalauthors, bibliosubjects, bibliosubtitles.
#
# Revision 1.157.2.31  2006/12/05 15:07:16  tipaul
# NEW FEATURE :
# a column (itemtypes.summary) has been added.
#
# If it is empty, no changes at all.
# In admin/itemtypes.pl, the librarian can go and define what (and how) the record appeard below the title.
# The summary must be entered exactly as the authority summary.
# An example is provided in admin/itemtypes.pl add/modify itemtype.
#
# This feature had been requested for a while by my librarians. The 2 uses we can imagine are :
# - for websites => show the link directly in the result list, to avoid 1 clic (& there is no need for a size/editor/publicationyear for web sites)
# - for serial publications => show some serial specific informations.
#
# This commit should do everything that is needed for this feature.
#
# Revision 1.157.2.30  2006/11/29 11:58:18  toins
# re indenting with space.
#
# Revision 1.157.2.29  2006/11/24 21:58:35  kados
# changing items.itemtype to items.itype to avoid problems with
# joins with biblioitems. NOTE: I don't think updatedatabase will remove the
# items.itemtype from your db so you must do that manually if you updated
# from an earlier version of updatedatabase.
#
# Revision 1.157.2.28  2006/11/24 13:54:55  hdl
# Adding serialsadditem
#
# Revision 1.157.2.27  2006/11/24 11:07:09  alaurin
# bug sanop #74 :
#
# Add a new system prefence "AutoLocation"
#  this fonction  switching activation or not Autolocation, if Yes, the Librarian can't change his location, it's defined by branchip,
# if autolocation is setting to "NO", librarian can change his settings ....
#
#
# warn, if autolocation is setting "on", on circulation.pl we don't have anymore the choice to change your library and branchprinter,
# defined on branches : branchip and branchprinter ....
#
# this function could be improved
#
# Revision 1.157.2.26  2006/11/23 11:01:06  toins
# branchtransfers.frombranch & branchtransfers.tobranch must be VARCHAR(10)
#
# Revision 1.157.2.25  2006/11/23 09:05:33  tipaul
# reintroducing move to innoDB (as only innoDB supports extended features like foreign keys)
#
# Revision 1.157.2.24  2006/11/21 09:15:23  toins
# better userflag description
#
# Revision 1.157.2.23  2006/11/21 08:51:01  toins
# 2 new userflags: serials & reports.
#
# Revision 1.157.2.22  2006/11/20 16:59:09  toins
# adding a userflags: 'editauthorities'.
#
# Revision 1.157.2.21  2006/11/17 10:53:04  hdl
# Changing
# - subscription detail :
#     adding manual history (in subscription table)
#     addind subscription summary.
# - menu-serials.inc deleting old link
# - adapting serials-collection.pl
#
# TODO List :
# - Some values are hard coded in subscription-detail
# - subscription-detail.pl relies on subscription-add for edition BUT subscription-add transmits back data to subscription-detail in order to save data back into database. This is a bit odd enough and should not occur.
# - Some more tests on numberlength which doesnot seem to be kept.
#
# Revision 1.157.2.20  2006/11/15 15:15:50  hdl
# Final First Version for New Facility for subscription management.
#
# Now
# use serials-collection.pl for history display
# and serials-edit.pl for serial edition
# subscription add and detail adds a new branch information to help IndependantBranches Library to manage different subscriptions for a serial
#
# This is aimed at replacing serials-receive and statecollection.
#
# Revision 1.157.2.19  2006/11/14 16:28:01  rych
# Adding itemtype field to items
#
# Revision 1.157.2.18  2006/11/14 16:16:58  rych
# fix mysql syntax
#
# Revision 1.157.2.17  2006/11/14 14:39:31  toins
# * delete the userflags "reservforself" which is unused.
# * some new function not use at the moment.
#
# Revision 1.157.2.16  2006/11/02 09:27:30  toins
# issue.branchcode must be varchar(10).
#
# Revision 1.157.2.15  2006/10/31 17:41:51  toins
# items.holdingbranch must be varchar(10)
#
# Revision 1.157.2.14  2006/10/30 09:41:45  btoumi
# remove auto increment for accountno in accountlines table
#
# Revision 1.157.2.13  2006/10/20 10:35:05  alaurin
# new program : branchoverdues.pl
#
# with this program, the librararians will can check , and specify the method of notification of documents in overdue
#
# little explanation :
#
#     - At first, the datas come from accountlines, generated by accounlines (type 'FU')
#     - There is three levels of notification (come from overduerules ....)
#     - there is four methods of notification :
#         - letter (for us, use an openoffice program ....)
#         - Mail (use a batch program)
#         - Phone (simple Method, if this method is selected, we consider that the borrower as been notified)
#         - Considered Lost (For us the third level)
#
#     - At this time we have some parameters hardcoded (Must be improve later)
#
#     - the choice of methods is hardcoded :
#         - for the first overduelevel : three methods : mail,letter,phone
#         -For the second overduelevel :only one method : letter
#         - For the Third Overdue level : only one method : Considered Lost
#
#
# this program will be heavy tested next week ....
#
# Revision 1.157.2.12  2006/10/19 09:04:07  toins
# itemtypes.itemtype is a primary key.
#
# Revision 1.157.2.11  2006/10/18 13:31:13  toins
# Borrowers.categorycode must have 10 chars lenght & categories.categorycode must be a primary key.
#
# Revision 1.157.2.10  2006/10/17 16:18:14  hdl
# Changing primary key in aqbookfund.
# Making it branchcode+aqbookfundid rather than simple aqbookfundid.
#
# Revision 1.157.2.9  2006/10/16 14:23:47  toins
# Borrowers.branchcode must be varchar(10) too.
#
# Revision 1.157.2.7  2006/10/11 15:22:23  tipaul
# - adding some missing fields, coming from dev_week :
# * lcsort & ccode in biblioitems table. lcsort is used for loc callnumbers & ccode is used to have a item level circulation rules. Ccode means C<irc>code
# * onloan & issue_date in items table. They are filled by the misc/update_items.pl script, with circulation values. NOW, onloan & issue_date in items are NOT set by circulation, this decision speed up a lot the circulation rate (with the Date::Manip removal). The price for this is to have the status of the item not real time updated in zebra, but that's worth the price.
# * cutterextra in items, that we should ask tumer to understand what it does  ;-)
#
# Revision 1.157.2.6  2006/10/10 11:25:40  btoumi
# add two tables : notifys , charges
# modify accountlines tables add two fields (notify_id and notify_level)
#
# Revision 1.157.2.5  2006/10/02 09:15:44  hdl
# Serials :
# * synching with NZ-devs on Serials.
# * adding routing lists support,
# * adding serialsadditems support
# * adding publisheddate management
#
# TODO :
# Management for seasonal serials should be fixed in order to be language independant.
#
# Revision 1.157.2.4  2006/09/19 07:44:13  btoumi
# bug fix : modify wrong field name BorrowerMandatoryField
#
# Revision 1.157.2.3  2006/09/18 14:00:24  btoumi
# bug fix :wrond field name for opacnote and contactnote
#
# Revision 1.157.2.2  2006/09/11 13:24:03  alaurin
# marcxml should be a longtext, some biblios can be more than 65535 char long
#
# Revision 1.157.2.1  2006/09/04 08:39:14  toins
# sync with rel_2_2.
#
# Revision 1.157  2006/08/11 10:03:13  tipaul
# the new "includes" features, for personalized templates. Look at koha-devel, i'll write a mail here (& something on the wiki)
#
# Revision 1.152  2006/06/27 09:26:37  btoumi
# modify (initials,phone ) fields property in borrowers and deletedborrowers table
#
# Revision 1.151  2006/06/22 10:33:14  btoumi
# sorry i forget deletedborrowers table
# modify firstname field from deletedborrowers table
#
# Revision 1.149  2006/06/20 22:35:47  rangi
# Code to allow the associated borrowers to work
#
# Revision 1.148  2006/06/17 22:12:01  rangi
# Adding id field to reviews table
#
# Revision 1.147  2006/06/17 03:36:41  rangi
# Table definition for the reviews table
#
# Revision 1.146  2006/06/17 03:29:41  rangi
# Variable to allow librarians to switch reviews on or off
#
# Revision 1.145  2006/06/16 09:45:02  btoumi
# updatedatabase.pl: add change of borrowers table to deletedborrowers table
# deletemem.pl: delete use of warn function
#
# Revision 1.144  2006/06/08 15:36:31  alaurin
# Add a new system preference 'AutomaticItemReturn' :
#
# if this prefence is switched on: the document returned in another library than homebranch, the system automaticly transfer the document to his homebranch (with notification for librarian in returns.tmpl) .
#
# switch off : the document stay in the holdingbranch ...
#
# correcting bugs :
# - comment C4::acquisition (not using in request.pl).
# - correcting date in request.pl
# -add the new call of function getbranches in request.pl
#
# Revision 1.143  2006/06/07 02:02:47  bob_lyon
# merging katipo changes...
#
# adding new preference IssuingInProcess
#
# Revision 1.142  2006/06/06 23:42:46  bob_lyon
# Merging Katipo changes...
#
# Adding new system pref where one can still retrieve a correct reading
# record history if one has moved older data from issues to oldissues table
# to speed up issues speed
#
# Revision 1.141  2006/06/01 03:18:11  rangi
# Adding a new column to the statistics table
#
# Revision 1.140  2006/05/22 22:40:45  rangi
# Adding new systempreference allowing for the library to add borrowers to institutions (rest homes, parishes, schools, classes etc).
#
# Revision 1.139  2006/05/19 19:31:29  tgarip1957
# Added new fields to auth_header and auth_subfield_table to allow ZEBRA use of authorities and new MARC framework like structure.
# Authority tables are modified to be compatible with new MARC frameworks. This change is part of Authority Linking & Zebra authorities. Requires change in Mysql database. It will break head unless all changes regarding this is implemented. This warning will take place on all commits regarding this
#
# Revision 1.138  2006/05/19 16:51:44  alaurin
# update database for :
# - new feature ip and printer management
# adding two fields in branches table (branchip,branchprinter)
#
# - waiting date : adding one field in reserves table(waiting date) to calculate the Maximum delay to pick up a reserved document when it's available
#
# new system preference :
# - ReservesMaxPickUpDelay : Maximum delay to pick up a reserved document
# TransfersMaxDaysWarning : Max delay before considering the transfer as potentialy a problem
#
# Revision 1.137  2006/04/18 09:36:36  plg
# bug fixed: typo fixed in labels and labels_conf tables creation query.
#
# Revision 1.136  2006/04/17 21:55:33  sushi
# Added 'labels' and 'labels_conf' tables, for spine lable tool.
#
# Revision 1.135  2006/04/15 02:37:03  tgarip1957
# Marc record should be set to UTF-8 in leader.Force it.
# XML should be with<record> wrappers
#
# Revision 1.134  2006/04/14 09:37:29  tipaul
# improvements from SAN Ouest Provence :
# * introducing a category_type into categories. It can be A (adult), C (children), P (Professionnal), I (institution/organisation).
# * each category_type has it's own forms to create members.
# * the borrowers table has been heavily modified (many fields changed), to get something more logic & readable
# * reintroducing guarantor/guanrantee system that is now independant from hardcoded C/A for categories
# * updating templates to fit template rules
#
# (see mail feb, 17 on koha-devel "new features for borrowers" for more details)
#
# Revision 1.133  2006/04/13 08:36:42  plg
# new: function C4::Date::get_date_format_string_for_DHTMLcalendar based on
# the system preference prefered date format.
#
# improvement: book fund list and budget list screen redesigned. Filters on
# each field. Columns are not sortable yet. Using DHTML Calendar to fill date
# fields instead of manual filling. Pagination system. From the book fund
# list, you can reach the budget list, filtered on a book fund, or not. A
# budget can be added only from book fund list screen.
#
# bug fixed: branchcode was missing in table aqbudget.
#
# bug fixed: when setting a branchcode to a book fund, all associated budgets
# move to this branchcode.
#
# modification: when adding/modifying budget/fund, MySQL specific "REPLACE..."
# statements replaced by standard SQL compliant statement.
#
# bug fixed: when adding/modifying a budget, if the book fund is associated to
# a branch, the branch selection is disabled and set to the book fund branch.
#
# Revision 1.132  2006/04/06 12:37:05  hdl
# Bugfixing : aqbookfund needed a field.
#
# Revision 1.131  2006/03/03 17:02:22  tipaul
# commit for holidays and news management.
# (some forgotten files)
#
# Revision 1.130  2006/03/03 16:35:21  tipaul
# commit for holidays and news management.
#
# Contrib from Tmer Garip (from Turkey) :
# * holiday :
# in /tools/ the holiday.pl script let you define holidays (days where the library is closed), branch by branch. You can define 3 types of holidays :
# - single day : only this day is closed
# - repet weekly (like "sunday") : the day is holiday every week
# - repet yearly (like "July, 4") : this day is closed every year.
#
# You can also put exception :
# - sunday is holiday, but "2006 March, 5th" the library will be open
#
# The holidays are used for return date calculation : the return date is set to the next date where the library is open. A systempreference (useDaysMode) set ON (Calendar) or OFF (Normal) the calendar calculation.
#
# Revision 1.129  2006/02/27 18:19:33  hdl
# New table used in overduerules.pl tools page.
#
# Revision 1.128  2006/01/25 15:16:06  tipaul
# updating DB :
# * removing useless tables
# * adding useful indexes
# * altering some columns definitions
# * The goal being to have updater working fine for foreign keys.
#
# For me it's done, let me know if it works for you. You can see an updated schema of the DB (with constraints) on the wiki
#
# Revision 1.127  2006/01/24 17:57:17  tipaul
# DB improvements : adding foreign keys on some tables. partial stuff done.
#
# Revision 1.126  2006/01/06 16:39:42  tipaul
# synch'ing head and rel_2_2 (from 2.2.5, including npl templates)
# Seems not to break too many things, but i'm probably wrong here.
# at least, new features/bugfixes from 2.2.5 are here (tested on some features on my head local copy)
#
# - removing useless directories (koha-html and koha-plucene)
#
# Revision 1.125  2006/01/04 15:54:55  tipaul
# utf8 is a : go for beta test in HEAD.
# some explanations :
# - updater/updatedatabase => will transform all tables in innoDB (not related to utf8, just to warn you) AND collate them in utf8 / utf8_general_ci. The SQL command is : ALTER TABLE tablename DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci.
# - *-top.inc will show the pages in utf8
# - THE HARD THING : for me, mysql-client and mysql-server were set up to communicate in iso8859-1, whatever the mysql collation ! Thus, pages were improperly shown, as datas were transmitted in iso8859-1 format ! After a full day of investigation, someone on usenet pointed "set NAMES 'utf8'" to explain that I wanted utf8. I could put this in my.cnf, but if I do that, ALL databases will "speak" in utf8, that's not what we want. Thus, I added a line in Context.pm : everytime a DB handle is opened, the communication is set to utf8.
# - using marcxml field and no more the iso2709 raw marc biblioitems.marc field.
#
# Revision 1.124  2005/10/27 12:09:05  tipaul
# new features for serial module :
# - the last 5 issues are now shown, and their status can be changed (but not reverted to "waited", as there can be only one "waited")
# - the library can create a "distribution list". this paper contains a list of borrowers (selected from the borrower list, or manually entered), and print it for a given issue. once printed, the sheet can be put on the issue and distributed to every reader on the list (one by one).
#
# Revision 1.123  2005/10/26 09:13:37  tipaul
# big commit, still breaking things...
#
# * synch with rel_2_2. Probably the last non manual synch, as rel_2_2 should not be modified deeply.
# * code cleaning (cleaning warnings from perl -w) continued
#
# Revision 1.122  2005/09/02 14:18:38  tipaul
# new feature : image for itemtypes.
#
# * run updater/updatedatabase to create imageurl field in itemtypes.
# * go to Koha >> parameters >> itemtypes >> modify (or add) an itemtype. You will see around 20 nice images to choose between (thanks to owen). If you prefer your own image, you also can type a complete url (http://www.myserver.lib/path/to/my/image.gif)
# * go to OPAC, and search something. In the result list, you now have the picture instead of the text itemtype.
#
# Revision 1.121  2005/08/24 08:49:03  hdl
# Adding a note field in serial table.
# This will allow librarian to mention a note on a peculiar waiting serial number.
#
# Revision 1.120  2005/08/09 14:10:32  tipaul
# 1st commit to go to zebra.
# don't update your cvs if you want to have a working head...
#
# this commit contains :
# * updater/updatedatabase : get rid with marc_* tables, but DON'T remove them. As a lot of things uses them, it would not be a good idea for instance to drop them. If you really want to play, you can rename them to test head without them but being still able to reintroduce them...
# * Biblio.pm : modify MARCgetbiblio to find the raw marc record in biblioitems.marc field, not from marc_subfield_table, modify MARCfindframeworkcode to find frameworkcode in biblio.frameworkcode, modify some other subs to use biblio.biblionumber & get rid of bibid.
# * other files : get rid of bibid and use biblionumber instead.
#
# What is broken :
# * does not do anything on zebra yet.
# * if you rename marc_subfield_table, you can't search anymore.
# * you can view a biblio & bibliodetails, go to MARC editor, but NOT save any modif.
# * don't try to add a biblio, it would add data poorly... (don't try to delete either, it may work, but that would be a surprise ;-) )
#
# IMPORTANT NOTE : you need MARC::XML package (http://search.cpan.org/~esummers/MARC-XML-0.7/lib/MARC/File/XML.pm), that requires a recent version of MARC::Record
# Updatedatabase stores the iso2709 data in biblioitems.marc field & an xml version in biblioitems.marcxml Not sure we will keep it when releasing the stable version, but I think it's a good idea to have something readable in sql, at least for development stage.
#
# Revision 1.119  2005/08/04 16:07:58  tipaul
# Synch really broke this script...
#
# Revision 1.118  2005/08/04 16:02:55  tipaul
# oops... error in synch between 2.2 and head
#
# Revision 1.117  2005/08/04 14:24:39  tipaul
# synch'ing 2.2 and head
#
# Revision 1.116  2005/08/04 08:55:54  tipaul
# Letters / alert system, continuing...
#
# * adding a package Letters.pm, that manages Letters & alerts.
# * adding feature : it's now possible to define a "letter" for any subscription created. If a letter is defined, users in OPAC can put an alert on the subscription. When an issue is marked "arrived", all users in the alert will recieve a mail (as defined in the "letter"). This last part (= send the mail) is not yet developped. (Should be done this week)
# * adding feature : it's now possible to "put to an alert" in OPAC, for any serial subscription. The alert is stored in a new table, called alert. An alert can be put only if the librarian has activated them in subscription (and they activate it just by choosing a "letter" to sent to borrowers on new issues)
# * adding feature : librarian can see in borrower detail which alerts they have put, and a user can see in opac-detail which alert they have put too.
#
# Note that the system should be generic enough to manage any type of alert.
# I plan to extend it soon to virtual shelves : a borrower will be able to put an alert on a virtual shelf, to be warned when something is changed in the virtual shelf (mail being sent once a day by cron, or manually by the shelf owner. Anyway, a mail won't be sent on every change, users would be spammed by Koha ;-) )
#
# Revision 1.115  2005/08/02 16:15:34  tipaul
# adding 2 fields to letter system :
# * module (acquisition, catalogue...) : it will be usefull to show the librarian only letters he may be interested by.
# * title, that will be used as mail subject.
#
# Revision 1.114  2005/07/28 15:10:13  tipaul
# Introducing new "Letters" system : Letters will be used everytime you want to sent something to someone (through mail or paper). For example, sending a mail for overdues use letter that you can put as parameters. Sending a mail to a borrower when a suggestion is validated uses a letter too.
# the letter table contains 3 fields :
# * code => the code of the letter
# * name => the complete name of the letter
# * content => the complete text. It's a TEXT field type, so has no limits.
#
# My next goal now is to work on point 2-I "serial issue alert"
# With this feature, in serials, a user can subscribe the "issue alert". For every issue arrived/missing, a mail is sent to all subscribers of this list. The mail warns the user that the issue is arrive or missing. Will be in head.
# (see mail on koha-devel, 2005/04/07)
#
# The "serial issue alert" will be the 1st to use this letter system that probably needs some tweaking ;-)
#
# Once it will be stabilised default letters (in any languages) could be added during installer to help the library begin with this new feature.
#
# Revision 1.113  2005/07/28 08:38:41  tipaul
# For instance, the return date does not rely on the borrower expiration date. A systempref will be added in Koha, to modify return date calculation schema :
# * ReturnBeforeExpiry = yes => return date can't be after expiry date
# * ReturnBeforeExpiry = no  => return date can be after expiry date
#
# Revision 1.112  2005/07/26 08:19:47  hdl
# Adding IndependantBranches System preference variable in order to manage Branch independancy.
#
# Revision 1.111  2005/07/25 15:35:38  tipaul
# we have decided that moving to Koha 3.0 requires being already in Koha 2.2.x
# So, the updatedatabase script can highly be cleaned (90% removed).
# Let's play with the new Koha DB structure now ;-)
#
